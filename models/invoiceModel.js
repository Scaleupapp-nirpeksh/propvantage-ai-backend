// File: models/invoiceModel.js
// Description: Invoice model for PropVantage AI - Production grade invoice management
// Version: 1.0 - Complete invoice schema with relationships and business logic
// Location: models/invoiceModel.js

import mongoose from 'mongoose';
import AutoIncrement from 'mongoose-sequence';

// Initialize auto-increment plugin
const autoIncrement = AutoIncrement(mongoose);

/**
 * Invoice Schema - Represents invoices generated for sales transactions
 * Integrates with Sale, Project, Unit, Lead (Customer), and Organization models
 */
const invoiceSchema = new mongoose.Schema({
  // === BASIC IDENTIFICATION ===
  
  // Auto-generated invoice number (per organization)
  invoiceNumber: {
    type: String,
    unique: true,
    index: true
  },
  
  // Sequential number for this organization
  sequenceNumber: {
    type: Number,
    // Will be auto-generated per organization
  },
  
  // Invoice prefix (customizable per organization)
  invoicePrefix: {
    type: String,
    default: 'INV',
    trim: true,
    maxlength: 10
  },
  
  // Financial year for the invoice
  financialYear: {
    type: String,
    required: true,
    trim: true
  },
  
  // === RELATIONSHIPS ===
  
  // Reference to the organization
  organization: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Organization',
    index: true
  },
  
  // Reference to the sale this invoice is for
  sale: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Sale',
    index: true
  },
  
  // Reference to the project
  project: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Project',
    index: true
  },
  
  // Reference to the unit
  unit: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Unit',
    index: true
  },
  
  // Reference to the customer (lead)
  customer: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Lead',
    index: true
  },
  
  // Generated by user
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'User',
    index: true
  },
  
  // === INVOICE DETAILS ===
  
  // Invoice type
  type: {
    type: String,
    enum: [
      'booking_invoice',      // Initial booking invoice
      'milestone_invoice',    // Milestone payment invoice
      'final_invoice',        // Final payment invoice
      'adjustment_invoice',   // Price adjustment invoice
      'cancellation_invoice', // Cancellation refund invoice
      'additional_charges'    // Additional charges invoice
    ],
    required: true,
    default: 'booking_invoice'
  },
  
  // Invoice status
  status: {
    type: String,
    enum: [
      'draft',        // Created but not finalized
      'generated',    // Finalized and ready to send
      'sent',         // Sent to customer
      'paid',         // Payment received
      'overdue',      // Payment overdue
      'cancelled',    // Invoice cancelled
      'partially_paid' // Partial payment received
    ],
    required: true,
    default: 'draft',
    index: true
  },
  
  // Invoice dates
  invoiceDate: {
    type: Date,
    required: true,
    default: Date.now,
    index: true
  },
  
  dueDate: {
    type: Date,
    required: true,
    index: true
  },
  
  sentDate: {
    type: Date,
    index: true
  },
  
  paidDate: {
    type: Date,
    index: true
  },
  
  // === FINANCIAL DETAILS ===
  
  // Line items from cost sheet
  lineItems: [{
    itemCode: {
      type: String,
      trim: true
    },
    description: {
      type: String,
      required: true,
      trim: true
    },
    category: {
      type: String,
      enum: [
        'base_price',
        'development_charges',
        'amenity_charges',
        'parking_charges',
        'club_membership',
        'maintenance_charges',
        'legal_charges',
        'other_charges',
        'taxes',
        'discounts'
      ],
      required: true
    },
    quantity: {
      type: Number,
      default: 1,
      min: 0
    },
    unitPrice: {
      type: Number,
      required: true,
      min: 0
    },
    totalPrice: {
      type: Number,
      required: true,
      min: 0
    },
    taxable: {
      type: Boolean,
      default: true
    },
    gstRate: {
      type: Number,
      default: 0,
      min: 0,
      max: 30
    },
    gstAmount: {
      type: Number,
      default: 0,
      min: 0
    }
  }],
  
  // Financial summary
  financialSummary: {
    subtotal: {
      type: Number,
      required: true,
      min: 0
    },
    discountAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    taxableAmount: {
      type: Number,
      required: true,
      min: 0
    },
    cgstAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    sgstAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    igstAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    totalGstAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    totalAmount: {
      type: Number,
      required: true,
      min: 0
    },
    amountInWords: {
      type: String,
      trim: true
    }
  },
  
  // Payment details
  paymentDetails: {
    totalPaid: {
      type: Number,
      default: 0,
      min: 0
    },
    pendingAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    lastPaymentDate: {
      type: Date
    },
    paymentMethod: {
      type: String,
      enum: ['cash', 'cheque', 'bank_transfer', 'card', 'online', 'other']
    },
    paymentReference: {
      type: String,
      trim: true
    }
  },
  
  // === TEMPLATE AND CUSTOMIZATION ===
  
  // Template used for generation
  template: {
    templateId: {
      type: String,
      default: 'default'
    },
    templateName: {
      type: String,
      default: 'Standard Invoice'
    },
    customFields: [{
      fieldName: String,
      fieldValue: String,
      fieldType: {
        type: String,
        enum: ['text', 'number', 'date', 'boolean'],
        default: 'text'
      }
    }]
  },
  
  // === DOCUMENT MANAGEMENT ===
  
  // Generated PDF file details
  pdfFile: {
    fileName: {
      type: String,
      trim: true
    },
    filePath: {
      type: String,
      trim: true
    },
    fileSize: {
      type: Number,
      min: 0
    },
    generatedAt: {
      type: Date
    }
  },
  
  // Email details
  emailDetails: {
    sentTo: [{
      email: {
        type: String,
        trim: true,
        lowercase: true
      },
      sentAt: {
        type: Date,
        default: Date.now
      },
      status: {
        type: String,
        enum: ['sent', 'delivered', 'failed', 'bounced'],
        default: 'sent'
      }
    }],
    emailSubject: {
      type: String,
      trim: true
    },
    emailBody: {
      type: String,
      trim: true
    },
    lastSentAt: {
      type: Date
    }
  },
  
  // === APPROVAL AND WORKFLOW ===
  
  // Approval workflow (if required)
  approvalWorkflow: {
    requiresApproval: {
      type: Boolean,
      default: false
    },
    approvalStatus: {
      type: String,
      enum: ['pending', 'approved', 'rejected'],
      default: 'approved'
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    approvedAt: {
      type: Date
    },
    rejectionReason: {
      type: String,
      trim: true
    }
  },
  
  // === AUDIT FIELDS ===
  
  // Revision tracking
  revision: {
    type: Number,
    default: 1,
    min: 1
  },
  
  // Previous version reference
  parentInvoice: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Invoice'
  },
  
  // Cancellation details
  cancellationDetails: {
    cancelledAt: {
      type: Date
    },
    cancelledBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    cancellationReason: {
      type: String,
      trim: true
    }
  },
  
  // Notes and comments
  notes: {
    internalNotes: {
      type: String,
      trim: true
    },
    customerNotes: {
      type: String,
      trim: true
    },
    paymentInstructions: {
      type: String,
      trim: true
    }
  },
  
  // System metadata
  metadata: {
    generationMethod: {
      type: String,
      enum: ['manual', 'automatic', 'bulk'],
      default: 'manual'
    },
    source: {
      type: String,
      enum: ['web_app', 'mobile_app', 'api', 'system'],
      default: 'web_app'
    },
    ipAddress: {
      type: String,
      trim: true
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// === INDEXES FOR PERFORMANCE ===

// Compound indexes for common queries
invoiceSchema.index({ organization: 1, invoiceNumber: 1 }, { unique: true });
invoiceSchema.index({ organization: 1, status: 1, invoiceDate: -1 });
invoiceSchema.index({ organization: 1, customer: 1, invoiceDate: -1 });
invoiceSchema.index({ organization: 1, project: 1, invoiceDate: -1 });
invoiceSchema.index({ organization: 1, dueDate: 1, status: 1 });
invoiceSchema.index({ organization: 1, financialYear: 1, sequenceNumber: 1 });

// Text search index
invoiceSchema.index({
  invoiceNumber: 'text',
  'notes.internalNotes': 'text',
  'notes.customerNotes': 'text'
});

// === VIRTUAL FIELDS ===

// Calculate days overdue
invoiceSchema.virtual('daysOverdue').get(function() {
  if (this.status !== 'overdue' && this.status !== 'partially_paid') {
    return 0;
  }
  const today = new Date();
  const diffTime = today - this.dueDate;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Calculate payment progress percentage
invoiceSchema.virtual('paymentProgress').get(function() {
  if (this.financialSummary.totalAmount === 0) return 0;
  return Math.round((this.paymentDetails.totalPaid / this.financialSummary.totalAmount) * 100);
});

// Generate display invoice number
invoiceSchema.virtual('displayInvoiceNumber').get(function() {
  return `${this.invoicePrefix}-${this.financialYear}-${String(this.sequenceNumber).padStart(6, '0')}`;
});

// === PRE-SAVE MIDDLEWARE ===

invoiceSchema.pre('save', async function(next) {
  try {
    // Generate invoice number if new document
    if (this.isNew) {
      // Generate financial year if not provided
      if (!this.financialYear) {
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        const currentMonth = currentDate.getMonth();
        
        // Financial year starts from April
        if (currentMonth >= 3) { // April to March
          this.financialYear = `${currentYear}-${(currentYear + 1).toString().slice(2)}`;
        } else {
          this.financialYear = `${currentYear - 1}-${currentYear.toString().slice(2)}`;
        }
      }
      
      // Auto-generate sequence number and invoice number
      if (!this.sequenceNumber) {
        await this.generateInvoiceNumber();
      }
      
      // Set due date if not provided (default 30 days)
      if (!this.dueDate) {
        this.dueDate = new Date(this.invoiceDate.getTime() + (30 * 24 * 60 * 60 * 1000));
      }
      
      // Calculate pending amount
      this.paymentDetails.pendingAmount = this.financialSummary.totalAmount - this.paymentDetails.totalPaid;
    }
    
    // Update status based on payment
    this.updateStatusBasedOnPayment();
    
    next();
  } catch (error) {
    next(error);
  }
});

// === INSTANCE METHODS ===

/**
 * Generate unique invoice number for the organization
 */
invoiceSchema.methods.generateInvoiceNumber = async function() {
  try {
    // Find the highest sequence number for this organization and financial year
    const lastInvoice = await this.constructor.findOne({
      organization: this.organization,
      financialYear: this.financialYear
    }).sort({ sequenceNumber: -1 });
    
    // Generate next sequence number
    this.sequenceNumber = lastInvoice ? lastInvoice.sequenceNumber + 1 : 1;
    
    // Generate formatted invoice number
    this.invoiceNumber = `${this.invoicePrefix}-${this.financialYear}-${String(this.sequenceNumber).padStart(6, '0')}`;
    
    return this.invoiceNumber;
  } catch (error) {
    throw new Error(`Failed to generate invoice number: ${error.message}`);
  }
};

/**
 * Update invoice status based on payment amount
 */
invoiceSchema.methods.updateStatusBasedOnPayment = function() {
  const totalAmount = this.financialSummary.totalAmount;
  const paidAmount = this.paymentDetails.totalPaid;
  const currentDate = new Date();
  
  if (paidAmount === 0) {
    // No payment received
    if (currentDate > this.dueDate && this.status !== 'cancelled') {
      this.status = 'overdue';
    } else if (this.status === 'draft') {
      // Keep as draft
    } else if (this.status !== 'cancelled') {
      this.status = 'sent';
    }
  } else if (paidAmount >= totalAmount) {
    // Fully paid
    this.status = 'paid';
    if (!this.paidDate) {
      this.paidDate = currentDate;
    }
  } else {
    // Partially paid
    this.status = 'partially_paid';
  }
  
  // Update pending amount
  this.paymentDetails.pendingAmount = Math.max(0, totalAmount - paidAmount);
};

/**
 * Record payment for this invoice
 */
invoiceSchema.methods.recordPayment = async function(paymentData) {
  try {
    const { amount, paymentMethod, paymentReference, paymentDate } = paymentData;
    
    // Validate payment amount
    if (amount <= 0) {
      throw new Error('Payment amount must be greater than 0');
    }
    
    if (this.paymentDetails.totalPaid + amount > this.financialSummary.totalAmount) {
      throw new Error('Payment amount exceeds invoice total');
    }
    
    // Update payment details
    this.paymentDetails.totalPaid += amount;
    this.paymentDetails.lastPaymentDate = paymentDate || new Date();
    this.paymentDetails.paymentMethod = paymentMethod;
    this.paymentDetails.paymentReference = paymentReference;
    
    // Update status
    this.updateStatusBasedOnPayment();
    
    await this.save();
    return this;
  } catch (error) {
    throw new Error(`Failed to record payment: ${error.message}`);
  }
};

/**
 * Cancel invoice
 */
invoiceSchema.methods.cancelInvoice = async function(cancellationData, userId) {
  try {
    if (this.status === 'paid') {
      throw new Error('Cannot cancel a paid invoice');
    }
    
    this.status = 'cancelled';
    this.cancellationDetails = {
      cancelledAt: new Date(),
      cancelledBy: userId,
      cancellationReason: cancellationData.reason || 'Invoice cancelled'
    };
    
    await this.save();
    return this;
  } catch (error) {
    throw new Error(`Failed to cancel invoice: ${error.message}`);
  }
};

/**
 * Mark invoice as sent
 */
invoiceSchema.methods.markAsSent = async function(emailData) {
  try {
    this.status = 'sent';
    this.sentDate = new Date();
    
    if (emailData) {
      this.emailDetails.sentTo.push({
        email: emailData.email,
        sentAt: new Date(),
        status: 'sent'
      });
      this.emailDetails.lastSentAt = new Date();
      this.emailDetails.emailSubject = emailData.subject;
      this.emailDetails.emailBody = emailData.body;
    }
    
    await this.save();
    return this;
  } catch (error) {
    throw new Error(`Failed to mark invoice as sent: ${error.message}`);
  }
};

// === STATIC METHODS ===

/**
 * Get invoice statistics for organization
 */
invoiceSchema.statics.getInvoiceStatistics = async function(organizationId, filters = {}) {
  try {
    const matchQuery = { organization: organizationId, ...filters };
    
    const stats = await this.aggregate([
      { $match: matchQuery },
      {
        $group: {
          _id: null,
          totalInvoices: { $sum: 1 },
          totalAmount: { $sum: '$financialSummary.totalAmount' },
          totalPaid: { $sum: '$paymentDetails.totalPaid' },
          totalPending: { $sum: '$paymentDetails.pendingAmount' },
          averageInvoiceValue: { $avg: '$financialSummary.totalAmount' }
        }
      }
    ]);
    
    const statusBreakdown = await this.aggregate([
      { $match: matchQuery },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          amount: { $sum: '$financialSummary.totalAmount' }
        }
      }
    ]);
    
    return {
      summary: stats[0] || {
        totalInvoices: 0,
        totalAmount: 0,
        totalPaid: 0,
        totalPending: 0,
        averageInvoiceValue: 0
      },
      statusBreakdown
    };
  } catch (error) {
    throw new Error(`Failed to get invoice statistics: ${error.message}`);
  }
};

/**
 * Get overdue invoices for organization
 */
invoiceSchema.statics.getOverdueInvoices = async function(organizationId) {
  try {
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    
    return await this.find({
      organization: organizationId,
      dueDate: { $lt: today },
      status: { $in: ['sent', 'overdue', 'partially_paid'] },
      'paymentDetails.pendingAmount': { $gt: 0 }
    })
    .populate('customer', 'firstName lastName email phone')
    .populate('project', 'name location')
    .populate('unit', 'unitNumber floor area')
    .sort({ dueDate: 1 });
  } catch (error) {
    throw new Error(`Failed to get overdue invoices: ${error.message}`);
  }
};

// === AUTO-INCREMENT SEQUENCE ===

// Add auto-increment for sequence number per organization
invoiceSchema.plugin(autoIncrement, {
  id: 'invoice_seq',
  inc_field: 'sequenceNumber',
  reference_fields: ['organization', 'financialYear']
});

// Create model
const Invoice = mongoose.model('Invoice', invoiceSchema);

export default Invoice;