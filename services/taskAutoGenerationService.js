// File: services/taskAutoGenerationService.js
// Description: Auto-generates tasks from business triggers (overdue payments, missed follow-ups, etc.)
// Uses cron scheduling and deduplication to prevent duplicate tasks.

import cron from 'node-cron';
import mongoose from 'mongoose';
import Task from '../models/taskModel.js';
import Organization from '../models/organizationModel.js';
import User from '../models/userModel.js';

// ‚îÄ‚îÄ‚îÄ HELPER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function dateKey() {
  const d = new Date();
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
}

function daysAgo(date) {
  return Math.ceil((Date.now() - new Date(date).getTime()) / (1000 * 60 * 60 * 24));
}

function priorityFromOverdueDays(days) {
  if (days > 30) return 'Critical';
  if (days > 14) return 'High';
  if (days > 7) return 'Medium';
  return 'Low';
}

/**
 * Find the org owner or business head to use as system creator
 */
async function getSystemUser(organizationId) {
  const owner = await User.findOne({
    organization: organizationId,
    isActive: true,
  })
    .populate('roleRef', 'level isOwnerRole')
    .sort({ 'roleRef.level': 1 });
  return owner?._id || null;
}

// ‚îÄ‚îÄ‚îÄ AUTO-GENERATION SERVICE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class TaskAutoGenerationService {
  constructor() {
    this.isRunning = false;
  }

  /**
   * Start all cron schedules
   */
  start() {
    // Run trigger checks every hour
    cron.schedule('0 * * * *', () => {
      console.log('üîÑ [TaskAutoGen] Running hourly trigger checks');
      this.runAllChecks();
    });

    // Check for recurring task generation every 15 minutes
    cron.schedule('*/15 * * * *', () => {
      this.generateRecurringTasks();
    });

    // Escalation checks every 30 minutes
    cron.schedule('*/30 * * * *', () => {
      this.checkEscalations();
    });

    console.log('‚úÖ [TaskAutoGen] Service started with cron schedules');
  }

  /**
   * Run all trigger checks across all active organizations
   */
  async runAllChecks() {
    if (this.isRunning) {
      console.log('‚è≥ [TaskAutoGen] Already running, skipping');
      return;
    }

    this.isRunning = true;
    try {
      const orgs = await Organization.find().select('_id');

      for (const org of orgs) {
        try {
          await this.checkOverduePayments(org._id);
          await this.checkMissedFollowUps(org._id);
          await this.checkDelayedMilestones(org._id);
          await this.checkNewSaleOnboarding(org._id);
        } catch (err) {
          console.error(
            `‚ùå [TaskAutoGen] Error for org ${org._id}: ${err.message}`
          );
        }
      }
    } catch (err) {
      console.error(`‚ùå [TaskAutoGen] runAllChecks failed: ${err.message}`);
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Check for overdue payment installments and create follow-up tasks
   */
  async checkOverduePayments(organizationId) {
    try {
      // Dynamic import to avoid circular dependencies
      const { default: Installment } = await import(
        '../models/installmentModel.js'
      );

      const now = new Date();
      const overdueInstallments = await Installment.find({
        organization: organizationId,
        currentDueDate: { $lt: now },
        status: { $nin: ['paid', 'waived', 'cancelled'] },
      })
        .populate({
          path: 'paymentPlan',
          select: 'sale',
          populate: { path: 'sale', select: 'salesPerson' },
        })
        .select('installmentNumber currentAmount currentDueDate paymentPlan')
        .limit(50);

      const systemUser = await getSystemUser(organizationId);
      if (!systemUser) return;

      for (const inst of overdueInstallments) {
        const dedupKey = `overdue_payment_${inst._id}_${dateKey()}`;

        const exists = await Task.findOne({
          'autoGenerated.deduplicationKey': dedupKey,
        }).select('_id');
        if (exists) continue;

        const overdueDays = daysAgo(inst.currentDueDate);
        const assignee =
          inst.paymentPlan?.sale?.salesPerson || systemUser;

        await Task.create({
          organization: organizationId,
          title: `Overdue Payment Follow-up: Installment #${inst.installmentNumber || 'N/A'}`,
          description: `Payment of ${inst.currentAmount} was due on ${inst.currentDueDate?.toLocaleDateString()}. Overdue by ${overdueDays} day(s). Please follow up with the customer.`,
          category: 'Payment & Collection',
          priority: priorityFromOverdueDays(overdueDays),
          status: 'Open',
          assignedTo: assignee,
          assignedBy: systemUser,
          assignmentType: 'system',
          dueDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
          linkedEntity: {
            entityType: 'Installment',
            entityId: inst._id,
            displayLabel: `Installment #${inst.installmentNumber || 'N/A'}`,
          },
          autoGenerated: {
            isAutoGenerated: true,
            triggerType: 'overdue_payment',
            triggerEntityType: 'Installment',
            triggerEntityId: inst._id,
            deduplicationKey: dedupKey,
          },
          createdBy: systemUser,
        });
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] checkOverduePayments error: ${err.message}`
      );
    }
  }

  /**
   * Check for leads with missed follow-up dates
   */
  async checkMissedFollowUps(organizationId) {
    try {
      const { default: Lead } = await import('../models/leadModel.js');

      const now = new Date();
      const missedLeads = await Lead.find({
        organization: organizationId,
        'followUpSchedule.nextFollowUpDate': { $lt: now },
        status: { $nin: ['Booked', 'Lost', 'Unqualified'] },
      })
        .select(
          'firstName lastName assignedTo followUpSchedule.nextFollowUpDate'
        )
        .limit(50);

      const systemUser = await getSystemUser(organizationId);
      if (!systemUser) return;

      for (const lead of missedLeads) {
        const dedupKey = `missed_follow_up_${lead._id}_${dateKey()}`;

        const exists = await Task.findOne({
          'autoGenerated.deduplicationKey': dedupKey,
        }).select('_id');
        if (exists) continue;

        const assignee = lead.assignedTo || systemUser;
        const overdueDays = daysAgo(
          lead.followUpSchedule?.nextFollowUpDate
        );

        await Task.create({
          organization: organizationId,
          title: `Follow-up Overdue: ${lead.firstName} ${lead.lastName}`,
          description: `Follow-up was due on ${lead.followUpSchedule?.nextFollowUpDate?.toLocaleDateString()}. Overdue by ${overdueDays} day(s).`,
          category: 'Lead & Sales',
          priority: overdueDays > 7 ? 'High' : 'Medium',
          status: 'Open',
          assignedTo: assignee,
          assignedBy: systemUser,
          assignmentType: 'system',
          dueDate: new Date(Date.now() + 1 * 24 * 60 * 60 * 1000),
          linkedEntity: {
            entityType: 'Lead',
            entityId: lead._id,
            displayLabel: `${lead.firstName} ${lead.lastName}`,
          },
          autoGenerated: {
            isAutoGenerated: true,
            triggerType: 'missed_follow_up',
            triggerEntityType: 'Lead',
            triggerEntityId: lead._id,
            deduplicationKey: dedupKey,
          },
          createdBy: systemUser,
        });
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] checkMissedFollowUps error: ${err.message}`
      );
    }
  }

  /**
   * Check for delayed construction milestones
   */
  async checkDelayedMilestones(organizationId) {
    try {
      const { default: ConstructionMilestone } = await import(
        '../models/constructionMilestoneModel.js'
      );

      const now = new Date();
      const delayedMilestones = await ConstructionMilestone.find({
        organization: organizationId,
        plannedEndDate: { $lt: now },
        status: { $nin: ['Completed', 'Cancelled'] },
      })
        .select('name assignedTo plannedEndDate project')
        .limit(50);

      const systemUser = await getSystemUser(organizationId);
      if (!systemUser) return;

      for (const ms of delayedMilestones) {
        const dedupKey = `delayed_milestone_${ms._id}_${dateKey()}`;

        const exists = await Task.findOne({
          'autoGenerated.deduplicationKey': dedupKey,
        }).select('_id');
        if (exists) continue;

        const delayDays = daysAgo(ms.plannedEndDate);
        const assignee = ms.assignedTo || systemUser;

        await Task.create({
          organization: organizationId,
          title: `Delayed Milestone: ${ms.name}`,
          description: `Construction milestone "${ms.name}" was due on ${ms.plannedEndDate?.toLocaleDateString()}. Delayed by ${delayDays} day(s).`,
          category: 'Construction',
          priority: priorityFromOverdueDays(delayDays),
          status: 'Open',
          assignedTo: assignee,
          assignedBy: systemUser,
          assignmentType: 'system',
          dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000),
          linkedEntity: {
            entityType: 'ConstructionMilestone',
            entityId: ms._id,
            displayLabel: ms.name,
          },
          autoGenerated: {
            isAutoGenerated: true,
            triggerType: 'delayed_milestone',
            triggerEntityType: 'ConstructionMilestone',
            triggerEntityId: ms._id,
            deduplicationKey: dedupKey,
          },
          createdBy: systemUser,
        });
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] checkDelayedMilestones error: ${err.message}`
      );
    }
  }

  /**
   * Check for new sales that need onboarding tasks
   */
  async checkNewSaleOnboarding(organizationId) {
    try {
      const { default: Sale } = await import('../models/saleModel.js');

      const recentSales = await Sale.find({
        organization: organizationId,
        status: 'Booked',
        createdAt: {
          $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        },
      })
        .select('salesPerson customer unit project')
        .populate('customer', 'firstName lastName')
        .limit(20);

      const systemUser = await getSystemUser(organizationId);
      if (!systemUser) return;

      for (const sale of recentSales) {
        const dedupKey = `new_sale_onboarding_${sale._id}`;

        const exists = await Task.findOne({
          'autoGenerated.deduplicationKey': dedupKey,
        }).select('_id');
        if (exists) continue;

        const customerName = sale.customer
          ? `${sale.customer.firstName} ${sale.customer.lastName}`
          : 'Customer';
        const assignee = sale.salesPerson || systemUser;

        await Task.create({
          organization: organizationId,
          title: `New Booking Onboarding: ${customerName}`,
          description: `New sale booked for ${customerName}. Please complete the onboarding checklist: collect KYC documents, send agreement draft, confirm payment schedule.`,
          category: 'Lead & Sales',
          priority: 'High',
          status: 'Open',
          assignedTo: assignee,
          assignedBy: systemUser,
          assignmentType: 'system',
          dueDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
          linkedEntity: {
            entityType: 'Sale',
            entityId: sale._id,
            displayLabel: `Sale - ${customerName}`,
          },
          checklist: [
            { text: 'Collect KYC documents from buyer', order: 1 },
            { text: 'Send agreement draft for review', order: 2 },
            { text: 'Confirm payment schedule with buyer', order: 3 },
            { text: 'Schedule registration date', order: 4 },
            { text: 'Send welcome kit / handover documents', order: 5 },
          ],
          autoGenerated: {
            isAutoGenerated: true,
            triggerType: 'new_sale_onboarding',
            triggerEntityType: 'Sale',
            triggerEntityId: sale._id,
            deduplicationKey: dedupKey,
          },
          createdBy: systemUser,
        });
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] checkNewSaleOnboarding error: ${err.message}`
      );
    }
  }

  /**
   * Generate tasks from recurring task definitions
   */
  async generateRecurringTasks() {
    try {
      const now = new Date();

      const recurringTasks = await Task.find({
        'recurrence.isRecurring': true,
        'recurrence.nextOccurrence': { $lte: now },
        status: { $nin: ['Cancelled'] },
      }).limit(50);

      for (const srcTask of recurringTasks) {
        // Check if end date passed
        if (
          srcTask.recurrence.endDate &&
          now > srcTask.recurrence.endDate
        ) {
          srcTask.recurrence.isRecurring = false;
          await srcTask.save();
          continue;
        }

        // Create new task instance
        await Task.create({
          organization: srcTask.organization,
          title: srcTask.title,
          description: srcTask.description,
          category: srcTask.category,
          priority: srcTask.priority,
          assignedTo: srcTask.assignedTo,
          assignedBy: srcTask.assignedBy,
          assignmentType: 'system',
          dueDate: this.calculateNextDueDate(srcTask),
          tags: srcTask.tags,
          checklist: srcTask.checklist.map((item) => ({
            text: item.text,
            order: item.order,
            isCompleted: false,
          })),
          linkedEntity: srcTask.linkedEntity,
          autoGenerated: {
            isAutoGenerated: true,
            triggerType: 'recurring_schedule',
            triggerEntityId: srcTask._id,
            triggerEntityType: 'Task',
            deduplicationKey: `recurring_${srcTask._id}_${dateKey()}`,
          },
          createdBy: srcTask.createdBy,
        });

        // Update next occurrence
        srcTask.recurrence.nextOccurrence = this.calculateNextOccurrence(
          srcTask.recurrence
        );
        await srcTask.save();
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] generateRecurringTasks error: ${err.message}`
      );
    }
  }

  /**
   * Calculate the next occurrence date based on recurrence pattern
   */
  calculateNextOccurrence(recurrence) {
    const now = new Date();
    const interval = recurrence.interval || 1;

    switch (recurrence.pattern) {
      case 'daily':
        return new Date(now.getTime() + interval * 24 * 60 * 60 * 1000);
      case 'weekly':
        return new Date(now.getTime() + interval * 7 * 24 * 60 * 60 * 1000);
      case 'biweekly':
        return new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000);
      case 'monthly': {
        const next = new Date(now);
        next.setMonth(next.getMonth() + interval);
        if (recurrence.dayOfMonth) {
          next.setDate(
            Math.min(
              recurrence.dayOfMonth,
              new Date(next.getFullYear(), next.getMonth() + 1, 0).getDate()
            )
          );
        }
        return next;
      }
      case 'quarterly': {
        const next = new Date(now);
        next.setMonth(next.getMonth() + 3);
        return next;
      }
      default:
        return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    }
  }

  /**
   * Calculate due date for a recurring task instance
   */
  calculateNextDueDate(srcTask) {
    if (srcTask.sla?.targetResolutionHours) {
      return new Date(
        Date.now() + srcTask.sla.targetResolutionHours * 60 * 60 * 1000
      );
    }
    // Default: same number of days as original task had
    if (srcTask.dueDate && srcTask.createdAt) {
      const originalDuration = srcTask.dueDate - srcTask.createdAt;
      return new Date(Date.now() + originalDuration);
    }
    return new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
  }

  /**
   * Check for tasks that need escalation
   */
  async checkEscalations() {
    try {
      const now = new Date();
      const twentyFourHoursAgo = new Date(
        now.getTime() - 24 * 60 * 60 * 1000
      );
      const fortyEightHoursAgo = new Date(
        now.getTime() - 48 * 60 * 60 * 1000
      );

      // Find overdue tasks that haven't been escalated yet (or need next level)
      const overdueTasks = await Task.find({
        status: { $nin: ['Completed', 'Cancelled'] },
        dueDate: { $lt: twentyFourHoursAgo },
        currentEscalationLevel: { $lt: 3 },
      })
        .populate('assignedTo', 'organization roleRef')
        .populate({
          path: 'assignedTo',
          populate: { path: 'roleRef', select: 'level' },
        })
        .limit(50);

      for (const task of overdueTasks) {
        const overdueSince = task.sla?.overdueSince || task.dueDate;
        const hoursSinceOverdue =
          (now - new Date(overdueSince)) / (1000 * 60 * 60);

        let shouldEscalate = false;
        let escalationLevel = task.currentEscalationLevel;

        if (escalationLevel === 0 && hoursSinceOverdue >= 24) {
          shouldEscalate = true;
          escalationLevel = 1;
        } else if (escalationLevel === 1 && hoursSinceOverdue >= 48) {
          shouldEscalate = true;
          escalationLevel = 2;
        } else if (escalationLevel === 2 && hoursSinceOverdue >= 72) {
          shouldEscalate = true;
          escalationLevel = 3;
        }

        if (!shouldEscalate) continue;

        // Find manager (user with lower role level in same org)
        const assigneeLevel =
          task.assignedTo?.roleRef?.level ?? 100;
        const manager = await User.findOne({
          organization: task.organization,
          isActive: true,
        })
          .populate('roleRef', 'level')
          .where('roleRef')
          .ne(null)
          .sort({ 'roleRef.level': 1 });

        // Find a user at a higher level than the assignee
        const escalateToUser = await User.findOne({
          organization: task.organization,
          isActive: true,
        })
          .populate('roleRef', 'level')
          .then(async () => {
            const candidates = await User.find({
              organization: task.organization,
              isActive: true,
            })
              .populate('roleRef', 'level')
              .select('_id roleRef');

            return candidates.find(
              (u) =>
                u.roleRef &&
                u.roleRef.level < assigneeLevel &&
                u._id.toString() !== task.assignedTo?._id?.toString()
            );
          });

        if (!escalateToUser) continue;

        task.escalations.push({
          level: escalationLevel,
          escalatedTo: escalateToUser._id,
          reason: `Task overdue by ${Math.round(hoursSinceOverdue)} hours (auto-escalation level ${escalationLevel})`,
        });
        task.currentEscalationLevel = escalationLevel;
        task.activityLog.push({
          action: 'escalated',
          details: {
            level: escalationLevel,
            escalatedTo: escalateToUser._id,
            hoursSinceOverdue: Math.round(hoursSinceOverdue),
          },
        });

        // Add manager as watcher
        if (
          !task.watchers.some(
            (w) => w.toString() === escalateToUser._id.toString()
          )
        ) {
          task.watchers.push(escalateToUser._id);
        }

        await task.save();
      }
    } catch (err) {
      console.error(
        `‚ùå [TaskAutoGen] checkEscalations error: ${err.message}`
      );
    }
  }
}

// Create singleton and export
const taskAutoGenerationService = new TaskAutoGenerationService();

export default taskAutoGenerationService;
